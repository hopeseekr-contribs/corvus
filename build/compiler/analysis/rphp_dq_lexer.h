#ifndef RPHP_NEXTDQTOKEN_DEC_18_2012_123540
#define RPHP_NEXTDQTOKEN_DEC_18_2012_123540
// Copyright (c) 2008-2009 Ben Hanson
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file licence_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// Auto-generated by boost::lexer
template<typename Iterator>
std::size_t rphp_nextDQToken (Iterator &start_token_, const Iterator &end_, 
    std::size_t &unique_id_)
{
    enum {end_state_index, id_index, unique_id_index, state_index, bol_index,
        eol_index, dead_state_index, dfa_offset};
    static const std::size_t npos = static_cast<std::size_t>(~0);
    static const std::size_t lookup_[256] = {6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 7, 6, 8, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        12, 12, 12, 12, 12, 12, 12, 12,
        12, 12, 6, 6, 6, 6, 6, 6,
        6, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 6, 9, 6, 6, 11,
        6, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 10, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 6, 6, 6, 6, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11,
        11, 11, 11, 11, 11, 11, 11, 11};
    static const std::size_t dfa_alphabet_ = 13;
    static const std::size_t dfa_[104] = {0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 3, 4, 2, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 6, 0, 0, 5, 0, 0, 1,
        126, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 7, 7,
        0, 1, 127, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 129,
        2, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 128, 3, 0, 0,
        0, 0, 0, 0, 0, 7, 7, 7};

    if (start_token_ == end_)
    {
        unique_id_ = npos;
        return 0;
    }

    const std::size_t *ptr_ = dfa_ + dfa_alphabet_;
    Iterator curr_ = start_token_;
    bool end_state_ = *ptr_ != 0;
    std::size_t id_ = *(ptr_ + id_index);
    std::size_t uid_ = *(ptr_ + unique_id_index);
    Iterator end_token_ = start_token_;

    while (curr_ != end_)
    {
        const std::size_t state_ =
            ptr_[lookup_[static_cast<unsigned char>(*curr_++)]];

        if (state_ == 0) break;

        ptr_ = &dfa_[state_ * dfa_alphabet_];

        if (*ptr_)
        {
            end_state_ = true;
            id_ = *(ptr_ + id_index);
            uid_ = *(ptr_ + unique_id_index);
            end_token_ = curr_;
        }
    }

    if (end_state_)
    {
        // return longest match
        start_token_ = end_token_;
    }
    else
    {
        // No match causes char to be skipped
        ++start_token_;
        id_ = npos;
        uid_ = npos;
    }

    unique_id_ = uid_;
    return id_;
}

#endif
